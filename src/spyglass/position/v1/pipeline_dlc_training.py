"""High-level function for running the Spyglass DLC Model Training V1 pipeline."""

from typing import Dict, Optional

import datajoint as dj

# --- Spyglass Imports ---
from spyglass.position.v1 import DLCModelSource  # To check results
from spyglass.position.v1 import (
    DLCModel,
    DLCModelSelection,
    DLCModelTraining,
    DLCModelTrainingParams,
    DLCModelTrainingSelection,
    DLCProject,
)
from spyglass.utils import logger

# --- Main Training Function ---


def run_spyglass_dlc_training_v1(
    project_name: str,
    training_params_name: str,
    dlc_training_params: Dict,
    dlc_model_params_name: str = "default",
    skip_duplicates: bool = True,
    training_id: Optional[int] = None,
    **kwargs,  # Pass-through for populate options
) -> Optional[str]:
    """Runs the Spyglass v1 DeepLabCut Model Training pipeline.

    Assumes the DLC project exists and frames have been labeled manually.
    This function defines the training parameters, selects the training run,
    and populates the `DLCModelTraining` table.

    Parameters
    ----------
    project_name : str
        The name of the existing DLC project in `DLCProject`.
    training_params_name : str
        A unique name for this set of training parameters to be stored in
        `DLCModelTrainingParams`.
    dlc_training_params : dict
        Dictionary containing the actual training parameters (e.g., {'maxiters': 50000}).
        See `DLCModelTrainingParams` for details.
    sampler : str, optional
        Frame sampler used ('uniform', 'kmeans'), needed to identify the TrainingSet.
        Defaults to 'uniform'.
    train_config_idx : int, optional
        The index (usually 0) of the 'train_config' file entry in DLCProject.File
        associated with this project. Defaults to 0.
    video_set_idx : int, optional
        The index of the 'video_sets' file entry in DLCProject.File if specific video sets
        were used for frame extraction. Defaults to None.
    model_prefix : str, optional
        Optional prefix for the model name. Defaults to "".
    skip_duplicates : bool, optional
        If True, skips insertion if entries already exist. Defaults to True.
    **kwargs : dict
        Additional keyword arguments passed to the `populate` call
        (e.g., `display_progress=True`, `reserve_jobs=True`).

    Returns
    -------
    str or None
        The `dlc_model_name` generated by the training if successful, None otherwise.

    Raises
    ------
    ValueError
        If required upstream entries (DLCProject, associated files) do not exist.
    DataJointError
        If there are issues during DataJoint table operations.

    Examples
    --------
    ```python
    # --- Example Prerequisites ---
    # Assume DLC project 'MyDLCProject_Test' exists and frames are labeled.

    project = 'MyDLCProject_Test'
    params_name = 'my_training_run_1'
    # Define training parameters (refer to DLCModelTrainingParams definition)
    train_params = {'maxiters': 10000, 'saveiters': 500}

    # --- Run Training ---
    # model_name = run_spyglass_dlc_training_v1(
    #     project_name=project,
    #     training_params_name=params_name,
    #     dlc_training_params=train_params,
    #     display_progress=True
    # )
    # if model_name:
    #     print(f"Training complete. Model Source Name: {model_name}")

    ```
    """
    # --- Input Validation ---
    project_key = {"project_name": project_name}
    if not (DLCProject & project_key):
        raise ValueError(f"DLCProject not found: {project_name}")

    # if training_id is not None or training_id <= 0:
    #     raise ValueError(
    #         f"Invalid training_id: {training_id}. Must be positive."
    #     )

    # --- 1. Insert Training Parameters ---
    params_key = {"dlc_training_params_name": training_params_name}
    if not (DLCModelTrainingParams & params_key):
        logger.info(
            f"Inserting DLC training parameters: {training_params_name}"
        )
        DLCModelTrainingParams.insert_new_params(
            paramset_name=training_params_name,
            params=dlc_training_params,
            skip_duplicates=skip_duplicates,
        )
    elif skip_duplicates:
        logger.warning(
            f"DLC training parameters '{training_params_name}' already exist."
        )
    else:
        raise dj.errors.DataJointError(
            f"DLC training parameters '{training_params_name}' already exist."
        )

    # --- 2. Insert Training Selection ---
    selection_key = {
        **project_key,
        "dlc_training_params_name": training_params_name,
        "training_id": 1 if training_id is None else training_id,
    }
    logger.info(
        f"---- Step 2: Inserting Training Selection for Project: {project_name} ----"
    )
    if not (DLCModelTrainingSelection & selection_key):
        DLCModelTrainingSelection.insert1(
            selection_key, skip_duplicates=skip_duplicates
        )
    else:
        logger.warning(
            f"DLC Training Selection already exists for {selection_key}"
        )
        if not skip_duplicates:
            raise dj.errors.DataJointError(
                "Duplicate training selection entry exists."
            )

    # Ensure selection exists before populating
    if not (DLCModelTrainingSelection & selection_key):
        raise dj.errors.DataJointError(
            f"Training selection key missing after insert attempt for {selection_key}"
        )

    dlc_model_name = None  # Initialize

    try:
        # --- 3. Populate Training ---
        logger.info(
            f"---- Step 3: Populating Training for Project: {project_name} ----"
        )
        if not (DLCModelTraining & selection_key):
            DLCModelTraining.populate(
                selection_key, reserve_jobs=True, **kwargs
            )
        else:
            logger.info(
                f"DLCModelTraining already populated for {selection_key}"
            )

        # Verify population and get the resulting model source name
        if not (DLCModelTraining & selection_key):
            raise dj.errors.DataJointError(
                f"DLCModelTraining population failed for {selection_key}"
            )

        if not (DLCModelSource() & selection_key):
            raise dj.errors.DataJointError(
                f"DLCModelSource entry missing for {selection_key}"
            )

        # Populate DLCModel
        logger.info(
            f"---- Step 4: Populating DLCModel for Project: {project_name} ----"
        )
        model_key = {
            **(DLCModelSource & selection_key).fetch1("KEY"),
            "dlc_model_params_name": dlc_model_params_name,
        }
        DLCModelSelection().insert1(
            model_key,
            skip_duplicates=True,
        )
        DLCModel.populate(model_key)

        if DLCModel & model_key:
            dlc_model_name = (DLCModel & model_key).fetch1("dlc_model_name")
            logger.info(
                f"==== Training Complete for Project: {project_name} ===="
            )
            logger.info(
                f"    -> Resulting DLC Model Source Name: {dlc_model_name}"
            )
        else:
            logger.error(
                f"Could not find resulting DLCModelSource entry after training for {selection_key}"
            )

    except dj.errors.DataJointError as e:
        logger.error(
            f"DataJoint Error during DLC training for {project_name}: {e}"
        )
        return None
    except Exception as e:
        logger.error(
            f"General Error during DLC training for {project_name}: {e}",
            exc_info=True,
        )
        return None

    return dlc_model_name  # Return the name needed for the processing pipeline
