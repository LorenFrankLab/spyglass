"""High-level function for running the Spyglass DLC Model Training V1 pipeline."""

from typing import Dict, Optional

import datajoint as dj

# --- Spyglass Imports ---
from spyglass.position.v1 import DLCModelSource  # To check results
from spyglass.position.v1 import (
    DLCModelTraining,
    DLCModelTrainingParams,
    DLCModelTrainingSelection,
    DLCProject,
)
from spyglass.utils import logger

# --- Main Training Function ---


def run_spyglass_dlc_training_v1(
    project_name: str,
    training_params_name: str,
    dlc_training_params: Dict,
    sampler: str = "uniform",  # Used to identify training set ID
    train_config_idx: int = 0,  # Index for train config in DLCProject.File
    video_set_idx: Optional[
        int
    ] = None,  # Index for videoset config in DLCProject.File
    model_prefix: str = "",
    skip_duplicates: bool = True,
    **kwargs,  # Pass-through for populate options
) -> Optional[str]:
    """Runs the Spyglass v1 DeepLabCut Model Training pipeline.

    Assumes the DLC project exists and frames have been labeled manually.
    This function defines the training parameters, selects the training run,
    and populates the `DLCModelTraining` table.

    Parameters
    ----------
    project_name : str
        The name of the existing DLC project in `DLCProject`.
    training_params_name : str
        A unique name for this set of training parameters to be stored in
        `DLCModelTrainingParams`.
    dlc_training_params : dict
        Dictionary containing the actual training parameters (e.g., {'maxiters': 50000}).
        See `DLCModelTrainingParams` for details.
    sampler : str, optional
        Frame sampler used ('uniform', 'kmeans'), needed to identify the TrainingSet.
        Defaults to 'uniform'.
    train_config_idx : int, optional
        The index (usually 0) of the 'train_config' file entry in DLCProject.File
        associated with this project. Defaults to 0.
    video_set_idx : int, optional
        The index of the 'video_sets' file entry in DLCProject.File if specific video sets
        were used for frame extraction. Defaults to None.
    model_prefix : str, optional
        Optional prefix for the model name. Defaults to "".
    skip_duplicates : bool, optional
        If True, skips insertion if entries already exist. Defaults to True.
    **kwargs : dict
        Additional keyword arguments passed to the `populate` call
        (e.g., `display_progress=True`, `reserve_jobs=True`).

    Returns
    -------
    str or None
        The `dlc_model_name` generated by the training if successful, None otherwise.

    Raises
    ------
    ValueError
        If required upstream entries (DLCProject, associated files) do not exist.
    DataJointError
        If there are issues during DataJoint table operations.

    Examples
    --------
    ```python
    # --- Example Prerequisites ---
    # Assume DLC project 'MyDLCProject_Test' exists and frames are labeled.

    project = 'MyDLCProject_Test'
    params_name = 'my_training_run_1'
    # Define training parameters (refer to DLCModelTrainingParams definition)
    train_params = {'maxiters': 10000, 'saveiters': 500}

    # --- Run Training ---
    # model_name = run_spyglass_dlc_training_v1(
    #     project_name=project,
    #     training_params_name=params_name,
    #     dlc_training_params=train_params,
    #     display_progress=True
    # )
    # if model_name:
    #     print(f"Training complete. Model Source Name: {model_name}")

    ```
    """
    # --- Input Validation ---
    project_key = {"project_name": project_name}
    if not (DLCProject & project_key):
        raise ValueError(f"DLCProject not found: {project_name}")

    # Find the TrainingSet ID based on sampler and file indices
    try:
        training_set_key = DLCModelTraining.get_training_set_key(
            project_name, sampler, train_config_idx, video_set_idx
        )
    except ValueError as e:
        raise ValueError(
            f"Could not find TrainingSet for project '{project_name}' with specified criteria: {e}"
        )

    # --- 1. Insert Training Parameters ---
    params_key = {"dlc_training_params_name": training_params_name}
    if not (DLCModelTrainingParams & params_key):
        logger.info(
            f"Inserting DLC training parameters: {training_params_name}"
        )
        DLCModelTrainingParams.insert_new_params(
            paramset_name=training_params_name,
            params=dlc_training_params,
            paramset_idx=0,  # Assuming first index if new
            skip_duplicates=skip_duplicates,
        )
    elif skip_duplicates:
        logger.warning(
            f"DLC training parameters '{training_params_name}' already exist."
        )
    else:
        raise dj.errors.DataJointError(
            f"DLC training parameters '{training_params_name}' already exist."
        )

    # --- 2. Insert Training Selection ---
    selection_key = {
        **training_set_key,  # Includes project_name, training_set_id
        "dlc_training_params_name": training_params_name,
        "model_prefix": model_prefix,
    }
    logger.info(
        f"---- Step 2: Inserting Training Selection for Project: {project_name} ----"
    )
    if not (DLCModelTrainingSelection & selection_key):
        DLCModelTrainingSelection.insert1(
            selection_key, skip_duplicates=skip_duplicates
        )
    else:
        logger.warning(
            f"DLC Training Selection already exists for {selection_key}"
        )
        if not skip_duplicates:
            raise dj.errors.DataJointError(
                "Duplicate training selection entry exists."
            )

    # Ensure selection exists before populating
    if not (DLCModelTrainingSelection & selection_key):
        raise dj.errors.DataJointError(
            f"Training selection key missing after insert attempt for {selection_key}"
        )

    dlc_model_name = None  # Initialize

    try:
        # --- 3. Populate Training ---
        logger.info(
            f"---- Step 3: Populating Training for Project: {project_name} ----"
        )
        if not (DLCModelTraining & selection_key):
            DLCModelTraining.populate(
                selection_key, reserve_jobs=True, **kwargs
            )
        else:
            logger.info(
                f"DLCModelTraining already populated for {selection_key}"
            )

        # Verify population and get the resulting model source name
        if not (DLCModelTraining & selection_key):
            raise dj.errors.DataJointError(
                f"DLCModelTraining population failed for {selection_key}"
            )

        # Fetch the linked DLCModelSource entry created by the training make method
        model_source_entry = DLCModelSource & (DLCModelTraining & selection_key)
        if model_source_entry:
            dlc_model_name = model_source_entry.fetch1("dlc_model_name")
            logger.info(
                f"==== Training Complete for Project: {project_name} ===="
            )
            logger.info(
                f"    -> Resulting DLC Model Source Name: {dlc_model_name}"
            )
        else:
            logger.error(
                f"Could not find resulting DLCModelSource entry after training for {selection_key}"
            )

    except dj.errors.DataJointError as e:
        logger.error(
            f"DataJoint Error during DLC training for {project_name}: {e}"
        )
        return None
    except Exception as e:
        logger.error(
            f"General Error during DLC training for {project_name}: {e}",
            exc_info=True,
        )
        return None

    return dlc_model_name  # Return the name needed for the processing pipeline
